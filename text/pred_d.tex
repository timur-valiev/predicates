\documentclass[a4paper,14pt]{extreport}
\usepackage[utf8]{inputenc}
%\usepackage[cp1251]{inputenc}
\usepackage[english,russian]{babel}
\usepackage[T2A]{fontenc}
\usepackage{amsmath,amssymb,epsfig}
\usepackage{paralist}
\usepackage{indentfirst}
\usepackage[width=17cm,height=24cm]{geometry}
\usepackage[unicode]{hyperref}
\usepackage{cmap}
\usepackage{graphicx}
%\hoffset=20mm
\voffset=8mm
\RequirePackage{enumitem}
%\textwidth=18cm
%\textheight=235mm
%\hoffset=-20mm
%voffset=-15mm
\setenumerate[1]{fullwidth }
\addto\captionsrussian{\def\contentsname{Оглавление}}
\addto\captionsrussian{\def\bibname{Список литературы}}
\makeatletter
\renewcommand{\@biblabel}[1]{#1.\hfil}
%\usepackage{titlesec}
\usepackage[titles]{tocloft}
\renewcommand{\cftchappresnum}{Глава~}
\renewcommand{\cftchapleader}{\bfseries\cftdotfill{\cftdotsep}}
\renewcommand{\cftchapaftersnum}{.}
\newlength{\zyvseclen}
\settowidth{\zyvseclen}{\bfseries\cftchappresnum\cftchapaftersnum}
%\addtolength{\zyvseclen}{2mm}
\addtolength{\cftchapnumwidth}{\zyvseclen}

\newcommand{\proof}{\trivlist \item[\hskip
      \labelsep{\bf Доказательство.}]}

\newtheorem{thm}{Теорема}
\newtheorem{lm}{Лемма}
\newtheorem{sld}{Следствие}
\newtheorem{zam}{Замечание}
\newtheorem{utv}{Утверждение}
\newtheorem{opr}{Определение}
\makeatletter
\def\thmstyle{\it}
\def\@begintheorem#1#2{\it \trivlist \item[\hskip
       \labelsep{\bf #1\ #2.}]\thmstyle}
\def\@opargbegintheorem#1#2#3{\it \trivlist \item[\hskip
       \labelsep{\bf #1\ #2\ (#3).}]\thmstyle}
\makeatother

\newcommand{\normI}{\renewcommand{\baselinestretch}{1.}}
\newcommand{\biggI}{\renewcommand{\baselinestretch}{1.1}}
\biggI

\begin{document}
\newpage
\tableofcontents
\newpage
\chapter{ Введение и постановка задачи }

\section{Введение}
Исследование систем $k$-значных функций было инициировано Э.Постом~\cite{post1,post2} для сдучая $k=2$.

Все предполные классы в $P_3$ и $P_4$ были описаны С.В.~Яблонским\cite{yabl}

Как известно, каждый предполный класс в $P_k$ можно задать как множество функций, сохраняющих некоторый предикат. Более того, Розенберг показал \cite{roz1, roz2}, что все эти предикаты можно разделить на 6 попарно непересекающихся семейств: $P$, $O$, $L$, $E$, $C$, $B$, описание которых можно найти в книге Марченкова С.С. \cite{march}. 

В моей курсовой работе за четвертый курс была написана программа на языке Java, которая генерирует предикаты, описанные выше, для $P_4$ и для каждой функции одной переменной из $P_4$ определяет все предполные классы, которым она принадлежит.

\section{Постановка задачи}
Пусть $Q, R$ — замкнутые классы и $Q \subset R$ (включение строгое). 
Говорят, что класс $Q$ предполон в классе $R$, если $[Q \cup \{f\}] = R$ для 
любой функции $f$ из множества $R \setminus Q$. 

\begin{itemize}
\item Для каждой функции двух переменных из $P_4$ определить все предполные классы, которым она принадлежит, построив при этом множество уникальных строк принадлежности функций двух переменных из $P_4$ предполным классам.
\end{itemize}

\newpage
\chapter{Описание программы}
Для решения задачи была взята и модифицирована программа из моей курсовой работы. Исходный код можно найти в \cite{git}. Там же можно найти описание модулей, созданных ранее, результаты и вспомогательные материалы, в частности и этот текст.

Ниже следует краткое описание сущностей, которые были реализованы в ходе курсовой работы и используются для генерации предикатов, задающих предполные классы.

\section{Описание сущностей}
Все определения сущностей находятся в пакете {\tt predicates.domain}
\subsection{Tuple}
Класс, который описывает упорядоченный набор чисел из capacity чисел от $0$ до $dim-1$. реализует интерфейсы {\tt Iterator} и {\tt Iterable}, что позволяет перебирать кортежи по порядку (лексикографическому).
\subsection{Function}
Класс, который описывает функцию, зависящую от $capacity$ переменных чисел, из $P_{dim}$, реализует интерфейсы {\tt Iterator} и {\tt Iterable}, что позволяет перебирать функции по порядку столбцов значений (лексикографическому).
\subsection{Permutation}
Класс, который описывает перестановку чисел от $0$ до $capacity-1$, реализует интерфейсы {\tt Iterator} и {\tt Iterable}, что позволяет перебирать перестановки по порядку (лексикографическому).
\subsection{Predicate} 
Описывает предикат, используя {\tt Set<ImmutableList<Integer> >} - множество векторов, удовлетворяющих предикату.

\section{Описание работы}
Основной сложностью, с которой пришлось столкнуться, при расширении программы явилось то, алгоритмы и структуры данных, использованные в работе с функциями одной переменной не были достаточно эффективными для работы с функциями двух переменных(по самым оптимистическим расчетам, программа должна была отработать за 250 дней, что было неприемлемо долго). 

Основная вычислительная нагрузка программы приходится на цикл, в котором перебираются функции и происходит проверка на принадлежность предполным классам. Исходя их этого, было решено повысить быстродействие путем оптимизаций алгоритмов проверки принадлежности и структур данных, отвечающих за хранение функций и предикатов.


\subsection{Оптимизация структур данных}
Для того, чтобы повысить быстродействие при работе с объектами, хранящими информацию о функциях и предикатах, было решено использовать упростить эти структуры. Это было достигнуто использованием стандартных массивов вместо списков и множеств, а так же использованием примитивных типов.

Были реализованы методы преобразования объектов из прошлой версии в новые, при работе которых совершаются предподсчеты, необходимые для более быстрой работы алгоритмов:
\begin{enumerate}
\item Для каждого предиката храним массив булевых переменных, $i$ элемент которого говорит нам о том, что вектор с кодом $i$ принадлежит предикату. 
\item Для каждого предиката храним массив кодов всех пар векторов, принадлежащих ему, и для каждого возможного кода в массиве храним, принадлежит ли он предикату.
\item Для каждой функции храним массив значений. 
\item Для каждой функции храним массив булевых значений, $i$ элемент которого указывает на то, может ли функция принимать значение $i$. 
\item Заводим дополнительный массив, в котором для каждого вектора пар аргументов будем сохранять вычисленные значения в виде кода вектора. 
\end{enumerate} 

\subsection{Оптимизация алгоритма перебора функций}
\begin{utv}
Если функция $f(x, y)$ сохраняет предикат $P$, то и функция $g(x, y) \equiv f(y, x)$ сохраняет его.
\end{utv}
Это утверждение следует из определения сохранения функцией предиката.

При помощи этого утверждения можно оптимизировать перебор следующим образом: если мы уже рассматривали функцию, которая сохраняет те же предикаты, то можно сразу перейти к следующему шагу цикла.

Если перебирать функции в лексикографическом порядке, то проверить условие досрочного перехода на следующий шаг цикла можно так: нужно взять пару аргументов $(i, j)$ такую, что код этой пары максимален, при том, что $i > j$ и $f(i, j) \neq f(j, i)$. Если такая пара нашлась, то можно не проверять функцию, если $f(i, j) > f(j, i)$.

\subsection{Алгоритм проверки сохранения функцией предиката}
Для проверки сохранения функцией предиката из семейства $B$ при $k = 4$ (существует единственный такой предикат) был введен отдельный алгоритм, в основе которого лежит следующее утверждение.
\begin{utv}
Если для функции $f(x, y)$ найдутся два вектора $(x_1, x_2, x_3, x_4), (y_1, y_2, y_3, y_4), x_i<4, y_i<4 $, таких, что в каждом найдется пара одинаковых чисел, и в векторе$(f(x_1, y_1),f(x_2, y_2),f(x_3, y_3),f(x_4, y_4))$ все элементы попарно различны, то функция $f$ не сохраняет предикат.  
\end{utv}
В алгоритме строятся такие вектора и в случае успеха, функция проверки возвращает $false$, иначе $true$.

Для всех остальных предикатов используется следующий алгоритм: перебираются коды всех пар векторов из предиката(они заранее предподсчитаны) и производится проверка, если ли среди векторов предиката тот, который возвращает функция. Если ответ отрицательный, то происходит возврат из функции со значением $false$. Если для всех пар векторов значение функции на них принадлежит предикату, то возвращается $true$. 


\newpage
\section{Поиск максимального по мощности базиса}
Рассмотрим задачу поиска базисов. Особый интерес представляет поиск максимальных или близких к ним по мощности. 

Для поиска решений был разработан переборный вероятностный алгоритм, использующий на входе полученную ранее таблицу принадлежности функций предполным классам и выдающий в бесконечном цикле наборы строк, соответствующие базисам. 

Сформулируем критерий, по которому будет определяться, соответствует ли набор строк таблицы какому-нибудь базису.
Каждой строке таблицы будем сопоставлять функцию(пример), на которой достигается распределение по предикатам описываемое данной строкой. Каждому столбцу ставится в соответствие предполный класс.  
\begin{utv}
Набор строк $R$ таблицы принадлежности функций предполным классам соответствует базису в $P_4$ тогда и только тогда, когда выполнены следующие условия:
\begin{itemize}
\item для каждого предполного класса(столбца) найдется функция(строка) из $R$, не лежащая в нем(на пересечении столбца и строки, соответствующим предикату и функции стоит $0$).    
\item для каждой функции(строки) найдется предикат(столбец) такой, что только эта функция(строка) из $R$ не принадлежит этому предикату(только на пересечении с этой строкой в столбце стоит $0$).   
\end{itemize}
Первое условие гарантирует покрытие всех предполных классов, второе - невозможность исключения из набора элементов без сохранения первого свойства. 
\end{utv}

\subsection{Сложность задачи}
\begin{thm}
Задача поиска максимального базиса по таблице принадлежности функций предполным классам NP-полна.
\end{thm}
\begin{proof}
Согласно общепринятому способу доказательства NP-полноты задач, сведем некоторую NP-полную задачу к нашей.

Рассмотрим следующий частный случай задачи поиска максимального базиса: пусть каждому предполному классу не принадлежат ровно 2 функции. Тогда таблица, соответствующая такой задаче, будет являться инвертированной матрицей инцидентности для некоторого графа(вершины графа будут соответствовать функциям, ребра -  предполным классам, которым они принадлежат не принадлежат). 

Посмотрим, какими свойствами будет обладать набор $R$ строк(вершин графа), который получится на выходе алгоритма поиска максимального по мощности базиса:
\begin{itemize}
\item максимальный по мощности    
\item для каждого класса(ребра) будет выбрана хотя бы одна строка(вершина, инцидентная ребру)
\item для каждой строки(вершины) существует класс(ребро), которому принадлежит(инцидентна) только она.    
\end{itemize}

Тогда дополнение $Q$ к этому найденному множеству будет обладать следующими свойствами:
\begin{itemize}
\item $Q$ минимальное по мощности    
\item никакие две вершины из $Q$ не будут смежными
\item для каждой вершины из $R$ найдется смежная ей вершина из $Q$     
\end{itemize}

Эти три свойства определяют минимальное независимое доминирующее множество(МНДМ). Задача поиска МНДМ в графе является NP-полной и сводится к поиску максимального базиса. За полиномиальное время можно проверить, является ли набор функция базисом. Из этого следует NP-полнота исходной задачи. 
   


\end{proof}
\subsection{Алгоритм}
описание алгоритма


\newpage
\chapter{Результаты работы за осенний семестр}
Был составлен список, с примерами функций, уникальных строк таблицы принадлежности функций двух переменных из $P_4$ предполным классам. 

\chapter{Планы на весенний семестр}
Получить нижние и верхние оценки для мощности множества всевозможных вариантов распределения функций четырехзначной логики по предполным классам.

Для получение хороших нижних оценок строятся примеры функций с различными распределениями по предполным классам(при помощи компьютера).

Для получение хороших верхних оценок формулируются и доказываются утверждения о вложении пересечения некоторых предполных классов в объединение других предполных классов.
  

\newpage
\addcontentsline{toc}{chapter}{Список литературы}
\begin{thebibliography}{9}
\bibitem{post1}	Post E.L. Introduction to a general theory of elementary propositions // 
Amer. J. Math.— 1921.- V. 43, №4.- P. 163-185. 
\bibitem{yabl} Е.Ю. Захарова, В.Б. Кудрявцев, С.В. Яблонский О предполных в $k$-значных логиках. // ДАН СССР, 1969, т.186, \No 3, стр.509-512 
\bibitem{post2}	Post E.L. Two-valued iterative systems of mathematical logic // Annals of 
Math. Studies. Princeton Univ. Press.— 1941.— V. 5. 
\bibitem{march} Марченков С.С. Функциональные системы с операцией суперпозиции
\bibitem{roz1}	Rosenberg I.G. La structure des fonctions de plusieurs variables sur un ensemble fini // C.R. Acad. Sci. Paris. Ser A.B.— 1965.— V. 260.— P. 3817- 3819. 
\bibitem{roz2}	Rosenberg I.G. Uber die funktionale Vollstandigkeit in den mehrwertigen Logiken // Rozpravy Ceskoslovenske Akad. Ved. Rada Math. Pfir. Ved. Praha.— 1970.— Bd. 80.- S. 3-93. 
\bibitem{git} Адрес проекта в интернете: https://github.com/zloi-timur/predicates 


\end{thebibliography}
\end{document}
