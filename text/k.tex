\documentclass[a4paper,14pt]{extreport}
\usepackage[utf8]{inputenc}
%\usepackage[cp1251]{inputenc}
\usepackage[english,russian]{babel}
\usepackage[T2A]{fontenc}
\usepackage{amsmath,amssymb,epsfig}
\usepackage{paralist}
\usepackage{indentfirst}
\usepackage[width=17cm,height=24cm]{geometry}
\usepackage[unicode]{hyperref}
\usepackage{cmap}
\usepackage{graphicx}
%\hoffset=20mm
\voffset=8mm
\RequirePackage{enumitem}
%\textwidth=18cm
%\textheight=235mm
%\hoffset=-20mm
%voffset=-15mm
\setenumerate[1]{fullwidth }
\addto\captionsrussian{\def\contentsname{Оглавление}}
\addto\captionsrussian{\def\bibname{Список литературы}}
\makeatletter
\renewcommand{\@biblabel}[1]{#1.\hfil}
%\usepackage{titlesec}
\usepackage[titles]{tocloft}
\renewcommand{\cftchappresnum}{Глава~}
\renewcommand{\cftchapleader}{\bfseries\cftdotfill{\cftdotsep}}
\renewcommand{\cftchapaftersnum}{.}
\newlength{\zyvseclen}
\settowidth{\zyvseclen}{\bfseries\cftchappresnum\cftchapaftersnum}
%\addtolength{\zyvseclen}{2mm}
\addtolength{\cftchapnumwidth}{\zyvseclen}

\newcommand{\proof}{\trivlist \item[\hskip
      \labelsep{\bf Доказательство.}]}

\newtheorem{thm}{Теорема}
\newtheorem{lm}{Лемма}
\newtheorem{sld}{Следствие}
\newtheorem{zam}{Замечание}
\newtheorem{utv}{Утверждение}
\newtheorem{opr}{Определение}
\makeatletter
\def\thmstyle{\it}
\def\@begintheorem#1#2{\it \trivlist \item[\hskip
       \labelsep{\bf #1\ #2.}]\thmstyle}
\def\@opargbegintheorem#1#2#3{\it \trivlist \item[\hskip
       \labelsep{\bf #1\ #2\ (#3).}]\thmstyle}
\makeatother

\newcommand{\normI}{\renewcommand{\baselinestretch}{1.}}
\newcommand{\biggI}{\renewcommand{\baselinestretch}{1.1}}
\biggI

\begin{document}
\newpage
\tableofcontents
\newpage
\chapter{ Введение и постановка задачи }

\section{Введение}
Как известно, каждый предполный класс в $P_k$ можно задать как множество функций, сохраняющих некоторый предикат. Более того, все эти предикаты можно разделить на 6 попарно непересекающихся семейств: $P, O, L, E, C, B$, описание которых можно найти в книге Марченкова С.С. <<Функциональные системы с операцией суперпозиции>>. 

\section{Постановка задачи}
\begin{itemize}
\item Найти все предикаты, описывающие предполные классы в $P_4$, разбив их на семейства.
\item Для каждой функции одной переменной из $P_4$ определить, каким предполным классам она принадлежит.
\end{itemize}
 

\chapter{Описание программы}
Для решения задачи была написана программа на языке программирования Java, исходный код которой можно найти, перейдя по следующей ссылке \url{https://github.com/zloi-timur/predicates} . Там же можно найти результаты и вспомогательные материалы, в том числе и этот текст.

Для создания проекта использовалась методология {\tt DDD(Domain-driven design)}, по этому хотелось бы начать с описания основных сущностей(реализованных в Java классах).

Т.к. при решении задачи часто приходилось перебирать однотипные объекты, многие классы реализуют интерфейсы {\tt Iterator} и {\tt Iterable}, что позволяет облегчить понимание исходного кода.
При написании программы часто использовались следующие обозначения: 
$Dim$ – “значность”, $Capacity$ – «местность».  

\section{Описание сущностей}
Все определения сущностей находятся в пакете {\tt predicates.domain}
\subsection{Tuple}
Класс, который описывает упорядоченный набор чисел из capacity чисел от $0$ до $dim-1$. реализует интерфейсы {\tt Iterator} и {\tt Iterable}, что позволяет перебирать кортежи по порядку(лексикографическому).
\subsection{Function}
Класс, который описывает функцию, зависящую от $capacity$ переменных чисел, из $P_dim$, реализует интерфейсы {\tt Iterator} и {\tt Iterable}, что позволяет перебирать функции по порядку столбцов значений (лексикографическому).
\subsection{Permutation}
Класс, который описывает перестановку чисел от $0$ до $capacity-1$. реализует интерфейсы {\tt Iterator} и {\tt Iterable}, что позволяет перебирать перестановки по порядку(лексикографическому).
\subsection{Predicate} 
Описывает предикат, храня {\tt Set<ImmutableList<Integer>>} - множество векторов, удовлетворяющих предикату.

\section{Описание алгоритмов нахождения и перебора предикатов}
Для каждого семейства предикатов был написан класс {\tt PredicateFactory\_X}, где X – название соответствующего семейства. Каждый из них реализует интерфейсы {\tt Iterable<Predicate>}, {\tt Iterator<Predicate>}.

Все они лежат в пакете {\tt predicates.factory}.

Т.к. при нахождении необходимых предикатов во многих случаях требуется перебор нескольких параметров и при некоторых комбинациях могут получаться  одинаковые результаты, необходимо было не выдавать уже полученные идентичные предикаты. Эта  проблема чаще всего решалась использованием структур данных, реализующих интерфейс {\tt Set<Predicate>}. 

Перейдем к подробному описанию каждого из модулей программы, соотвествующих семействам предикатов.

\subsection{Модуль PredicateFactory\_P}
Каждый из предикатов класса $Р$ задается перестановкой, которая является произведением циклов одной и той же простой длины(в нашем случае получается $2$ цикла длины $2$), по этому для нахождения всех предикатов программа перебирает все перестановки, проверяет на выполнение вышеописанного условия(в классе {\tt Permutation} есть соответствующий метод) и, при успешном результате проверки, строит предикат.

\subsection{Модуль PredicateFactory\_O}
Семейство $О$ содержит любой двуместный предикат, который задает на $E_k$ частичный порядок с
наименьшим и наибольшим элементами (ограниченный частичный порядок). 

Для нахождения всех таких предикатов программа перебирает все перестановки чисел от $0$ до $dim-1$(от $0$ до $3$ в нашем случае), считая, что первый элемент перестановки будет наибольшим, последний – наименьшим. 

Далее берутся все пары элементов $(a_i,a_j)$, где $i<j$ и перебираются все из $2^{(k-2)*(k-3)}$ вариантов считать или не считать, что эта пара упорядочена, причем отсекаются те конфигурации, в которых не выполняется транзитивность. Для каждого подошедшего варианта строится предикат.

\subsection{Модуль PredicateFactory\_E}
Семейство $Е$ состоит из всех двуместных предикатов, которые  представляют собой отношения эквивалентности на $E_k$, отличные от полного и единичного отношений (нетривиальные отношения эквивалентности). Таким образом, каждое отношение эквивалентности из $Е$ разбивает множество $Е_k$ на $l$ классов попарно эквивалентных элементов, где $1 < l < к$. 

Нахождение всех таких предикатов осуществляется при помощи перебора всех возможных разбиений и построения соответствующих предикатов. 

\subsection{Модуль PredicateFactory\_L}
Предикаты этого семейства существуют только при $k = p^l$ где $р$ — простое число и $l > 0$. В этом случае на множестве $E_k$ можно определить бинарную коммутативную операцию $+$ так, 
что $G = <E_k;+>$ будет являться абелевой $р$-группой периода $р$ . Иными словами, в абелевой группе $G$ порядок любого элемента, отличного от нуля группы, равен $р$. 

Итак, если $к = р^l4$ и $G = (Е_k; +)$ — абелева $р$-группа периода $р$, то семейству $L$ принадлежит предикат $x_1+x_2=x_3+x_4$. 

В нашем случае $p=l=2$ и существует только одна таблица сложения, удовлетворяющая описанным условиям: ${{0, 1, 2, 3};{1, 0, 3, 2};{2, 3, 0, 1};{3, 2, 1, 0}}$. 

Для нахождения всех таких предикатов программа перебирает все перестановки чисел от $0$ до $dim-1$(от $0$ до $3$ в нашем случае) и строит предикат $x_1+x_2=x_3+x_4$. При $k=4$ для всех перестановок предикаты оказались равными.
\subsection{Модуль PredicateFactory\_C}
Семейство $С$ состоит из всех центральных предикатов.

\begin{opr} Предикат $р(х_1,...,x_m )$ называется центральным, если он вполне рефлексивен, вполне симметричен, отличен от тождественно истинного предиката и существует такое непустое подмножество $С$ множества $E_k$ [центр предиката $р$),  что предикату $р$ удовлетворяет всякий набор $(a_1,..., а_m)$ из $Е_k^m$, как только ${а_1,..., а_m} \cap С \neq \emptyset$.
\end{opr}
\begin{opr}Предикат $p(x_1,..., x_m)$ называется вполне рефлексивным, если либо $m = 1$, либо  если $m > 1$ и $p(a_1,..., а_m) = True$ для любого набора $(a_1,...,a_m)$ из $Е_k^m$, содержащего не более $m — 1$ различных значений.
\end{opr}
\begin{opr} 
Предикат $р$ называется вполне симметричным, если он не меняется при любой перестановке переменных.  
\end{opr}

Для перебора всех предикатов нам необходимо перебрать размерность предиката.

Далее, для каждой размерности, мы строим минимальный вполне рефлексивный предикат.
На следующем шаге мы перебираем все возможные центры и добавляем вектора, которые имеют с ним непустое пересечение, в предикат.

На последнем этапе перебора мы  всеми возможными способами пытаемся его расширить еще не вошедшими векторами, учитывая условия симметричности и нетривиальности.
\subsection{Модуль PredicateFactory\_B}
Если $h \geqslant З, l \geqslant 1, k \geqslant h^l$ и $q$ — отображение множества $Е_k$ на  множество $Е_{h^l}$, то семейству $В$ принадлежит предикат, который является полным прообразом $l$-й декартовой степени предиката $\tau$ при отображении $q$.

При $k=4$ нам подходит $h=3,4$ и $l =1$.

Для каждого из двух вариантов построим множества предикатов следующим образом:
\begin{enumerate}
\item переберем все отображения множества $Е_k$ на  множество $Е_{h^l}$.
\item для каждого отображения будем строить предикат answer, перебирая все возможные кортежи и проверяя, должны ли они входить в него при условии того, что answer должен быть прообразом предиката $\tau$.
\end{enumerate} 
\section{Получение результатов}
Теперь, получив все искомые предикаты, необходимо проверить, какие функции сохраняют их. Для такой проверки в проекте есть класс PredicateService, который содержит метод с сигнатурой {\tt public static boolean checkSave(Predicate predicate, Function function)}. 

Теперь достаточно перебрать все пары, состоящие из функций и найденных предикатов, и применить к ним данный метод.

\chapter{Результаты и заключение}
\begin{enumerate}
\item Были найдены все предикаты, описывающие предполные классы в $P_4$, и построена таблица(см. приложение А) принадлежности функций одной переменной четырехзначной логики этим предикатам. 
\item Была создан Java-проект с архитектурой, позволяющей использовать его для задач, связанных с предикатами и предполными классами при значениях $k>4$(сейчас только при нахождении предикатов семейств $L$ и $B$ есть ограничения на $k$).
\end{enumerate}


\newpage
\addcontentsline{toc}{chapter}{Список литературы}
\begin{thebibliography}{9}
\bibitem{march} Марченкова С.С. Функциональные системы с операцией суперпозиции
\end{thebibliography}
\end{document}
